{"version":3,"sources":["../../src/api/useFind.js"],"names":["PouchDB","find","collate","matchesSelector","reverseArgs","changes","useDB","plugin","changesOptions","live","include_docs","since","return_docs","useListen","useFind","options","db","callee","example","selector","limit","skip","sort","setValue","createIndex","index","fields","map","field","Object","keys","docs","update","deleted","doc","findIndex","_id","found","splice","length","replacementDoc","push","sortOrders","prop","entries","a","b","order","result","sortedIndex","lastDoc","firstDoc"],"mappings":"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","sourcesContent":["import PouchDB from 'pouchdb';\nimport find from 'pouchdb-find';\nimport { collate } from 'pouchdb-collate';\nimport { matchesSelector } from 'pouchdb-selector-core';\nimport reverseArgs from '../utils/reverseArgs';\nimport changes from '../changes';\nimport useDB from '../useDB';\n\nPouchDB.plugin(find);\n\nconst changesOptions = {\n  live: true,\n  include_docs: true,\n  since: 'now',\n  // Documents are kept in memory. 'complete' event can return an empty array.\n  return_docs: false\n};\n\nexport default useListen =>\n  reverseArgs(function useFind(options, db) {\n    db = useDB(db, {\n      callee: 'useFind',\n      example: 'useFind(db, options)'\n    });\n    const { selector, limit, skip, sort } = options;\n\n    return useListen(db, options, async setValue => {\n      if (sort) {\n        await db.createIndex({\n          index: {\n            fields: sort.map(field =>\n              typeof field === 'object' ? Object.keys(field)[0] : field\n            )\n          }\n        });\n      }\n      let { docs } = await db.find(options);\n      const update = () => setValue([...docs]);\n      update();\n      // To find deleted and other non-matching documents, listen all changes and use selector in 'change' event.\n      return db::changes(\n        changesOptions, //\n        async ({ deleted, doc }) => {\n          const index = docs?.findIndex(({ _id }) => doc._id === _id);\n          const found = index !== -1;\n          // Document was deleted or it does not match the selector?\n          if (deleted || (selector && !matchesSelector(doc, selector))) {\n            if (found) {\n              // Remove.\n              docs.splice(index, 1);\n              const { length } = docs;\n              // At the limit?\n              if (length + 1 === limit) {\n                const {\n                  docs: [replacementDoc]\n                } = await db.find({\n                  ...options,\n                  limit: 1,\n                  skip: (options.skip || 0) + length\n                });\n                if (replacementDoc) {\n                  docs.push(replacementDoc);\n                }\n              }\n              update();\n            }\n          } else {\n            if (found) {\n              // Update.\n              docs[index] = doc;\n            } else {\n              // Create.\n              if (!docs) {\n                docs = [];\n              }\n              docs.push(doc);\n            }\n            if (sort) {\n              const sortOrders = sort.map(prop =>\n                typeof prop === 'object'\n                  ? Object.entries(prop)[0]\n                  : // Default sort order is 'asc'\n                    [prop, 'asc']\n              );\n              docs.sort((a, b) => {\n                for (const [prop, order] of sortOrders) {\n                  const result = collate(a[prop], b[prop]);\n                  if (result !== 0) {\n                    return order === 'asc' ? result : -result;\n                  }\n                }\n                return 0;\n              });\n            }\n            const sortedIndex = docs.findIndex(({ _id }) => doc._id === _id);\n            // Document update, new place is supposed to be last, `limit` option is set and limit was reached?\n            if (found && sortedIndex + 1 === limit) {\n              // Get the actual last document.\n              const {\n                docs: [lastDoc]\n              } = await db.find({\n                ...options,\n                limit: 1,\n                skip: (options.skip || 0) + sortedIndex\n              });\n              if (lastDoc?._id !== doc._id) {\n                docs[sortedIndex] = lastDoc;\n              }\n            }\n            // `skip` option is set and document is supposed to be first?\n            if (skip && sortedIndex === 0) {\n              // Get the actual first document.\n              const {\n                docs: [firstDoc]\n              } = await db.find({\n                ...options,\n                limit: 1\n              });\n              if (firstDoc?._id !== doc._id) {\n                docs[0] = firstDoc;\n              }\n            }\n            if (docs.length > limit) {\n              docs.splice(limit);\n            }\n            update();\n          }\n        }\n      );\n    });\n  });\n"],"file":"useFind.js"}